(function(t,e){typeof exports=="object"&&typeof module<"u"?e(exports,require("liveprinter-utils"),require("tonal")):typeof define=="function"&&define.amd?define(["exports","liveprinter-utils","tonal"],e):(t=typeof globalThis<"u"?globalThis:t||self,e(t["liveprinter-core"]={},t.liveprinterUtils,t.tonal))})(this,function(exports,liveprinterUtils,tonal){"use strict";const MAX_SPEED={UM2plus:{maxTravel:{x:300,y:300,z:80,e:45},maxPrint:{x:250,y:250,z:150,e:45}},UM2:{maxTravel:{x:300,y:300,z:80,e:45},maxPrint:{x:250,y:250,z:150,e:45}},UM3:{maxTravel:{x:300,y:300,z:80,e:45},maxPrint:{x:250,y:250,z:150,e:45}},REPRAP:{maxTravel:{x:300,y:300,z:80,e:45},maxPrint:{x:250,y:250,z:150,e:45}}},BED_SIZE={UM3:{x:223,y:223,z:305},UM2:{x:223,y:223,z:205},UM2plus:{x:223,y:223,z:305},REPRAP:{x:150,y:150,z:80}},SPEED_SCALE={UM3:{x:47.069852,y:47.069852,z:160},UM2:{x:47.069852,y:47.069852,z:160},UM2plus:{x:47.069852,y:47.069852,z:160},REPRAP:{x:47.069852,y:47.069852,z:160}},FilamentDiameter={UM3:2.85,UM2:2.85,UM2plus:2.85,REPRAP:1.75},ExtrusionInmm3={UM3:!1,UM2:!1,UM2plus:!0,REPRAP:!1};/**
 * Core Printer API of LivePrinter, an interactive programming system for live CNC manufacturing.
 * @version 1.0
 * @example <caption>Log GCode to console:</caption>
 * let printer = new Printer(msg => Logger.debug(msg)); * Communications between server, GUI, and events functionality for LivePrinter.
 * @author Evan Raskob <evanraskob+nosp4m@gmail.com>
 * @version 1.0
 * @license
 * Copyright (c) 2022 Evan Raskob and others
 * Licensed under the GNU Affero 3.0 License (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     {@link https://www.gnu.org/licenses/gpl-3.0.en.html}
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */const MinLayerHeight=.05,MIN_INTERVAL=5.357,TimeRegex=/(\d+|\d+\.\d+|\d+\/\d+)(s|ms|b)/i;class LivePrinter{constructor(t="UM2plus"){this.ext=this.extrude,this.ext2=this.extrudeto,this.mov=this.move,this.mov2=this.moveto,this.tur=this.turn,this.tur2=this.turnto,this.ret=this.retract,this.unret=this.unretract,this.gcodeListeners=[],this.printListeners=[],this.errorListeners=[],this.opListeners=[],this._layerHeight=.2,this.lastSpeed=-1,this._heading=0,this._elevation=0,this._distance=0,this._waitTime=0,this._autoRetract=!0,this._bpm=120,this._intervalTime=16,this.totalMoveTime=0,this.maxFilamentPerOperation=30,this.minFilamentPerOperation=2e-4,this.maxTimePerOperation=6e4,this.currentRetraction=0,this.retractLength=8.5,this._retractSpeed=30*60,this.firmwareRetract=!1,this.extraUnretract=0,this.unretractZHop=0,this.boundaryMode="stop",this.maxMovePerCycle=200,this.setProperties(t)}setProperties(t){this._model=t,this._maxTravelSpeed=MAX_SPEED[t].maxTravel,this._maxPrintSpeed=MAX_SPEED[t].maxPrint,this._travelSpeed=this._maxTravelSpeed.x,this._printSpeed=this._maxPrintSpeed.x/3,this._speedScale=SPEED_SCALE[t],this._bedSize=BED_SIZE[t],this._extrusionInmm3=ExtrusionInmm3[t],this._filamentDiameter=FilamentDiameter[t],this.minPosition=new liveprinterUtils.Vector({x:0,y:0,z:0,e:-99999}),this.maxPosition=new liveprinterUtils.Vector({x:this._bedSize.x,y:this._bedSize.y,z:this._bedSize.z,e:999999}),this.position=new liveprinterUtils.Vector({x:this.minPosition.axes.x,y:this.minPosition.axes.y,z:this.minPosition.axes.z,e:0})}async gcodeEvent(t){await Promise.all(this.gcodeListeners.map(async e=>e.gcodeEvent(t))),liveprinterUtils.Logger.debug(t)}async gcode(t){return this.gcodeEvent(t)}async printEvent(t){await Promise.all(this.printListeners.map(async e=>e.printEvent(t))),liveprinterUtils.Logger.debug(`Print event: ${JSON.stringify(t,null,2)}`)}async errorEvent(t){await Promise.all(this.errorListeners.map(async e=>e.errorEvent(t)))}addGCodeListener(t){this.gcodeListeners.includes(t)||this.gcodeListeners.push(t)}addPrintListener(t){this.printListeners.includes(t)||this.printListeners.push(t)}addErrorListener(t){this.errorListeners.includes(t)||this.errorListeners.push(t)}removeGCodeListener(t){this.gcodeListeners=this.gcodeListeners.filter(e=>e!=t)}removePrintListener(t){this.printListeners=this.printListeners.filter(e=>e!=t)}removeErrorListener(t){this.errorListeners=this.errorListeners.filter(e=>e!=t)}get x(){return this.position.axes.x}get y(){return this.position.axes.y}get z(){return this.position.axes.z}get e(){return this.position.axes.e}set x(t){this.position.axes.x=t}set y(t){this.position.axes.y=t}set z(t){this.position.axes.z=t}set e(t){this.position.axes.e=t}get time(){return this.totalMoveTime}set optime(t){this.maxTimePerOperation=t}get optime(){return this.maxTimePerOperation}set model(t){this.setProperties(t)}get model(){return this._model}printspeed(t){if(t!==void 0){const e=this.parseAsTime(t);let i=this._maxPrintSpeed;this._printSpeed=Math.min(e,parseFloat(i.x))}return this._printSpeed}psp(t){return this.printspeed(t)}drawspeed(t){return this.printspeed(t)}dsp(t){return this.printspeed(t)}travelspeed(t){if(t!==void 0){const e=this.parseAsTime(t);let i=this._maxTravelSpeed;this._travelSpeed=Math.min(e,parseFloat(i.x))}return this._travelSpeed}tsp(t){return this.travelspeed(t)}speed(t){return this.printspeed(this.travelspeed(t))}get maxspeed(){return this._maxPrintSpeed.x}get extents(){return this.maxPosition.axes}autoretract(t=!0){return t?this._autoRetract=t:this._autoRetract=!1,this._autoRetract}get cx(){return this.minx+(this.maxx-this.minx)/2}get cy(){return this.miny+(this.maxy-this.miny)/2}get minx(){return this.minPosition.axes.x}get miny(){return this.minPosition.axes.y}get minz(){return this.minPosition.axes.z}set minx(t){this.minPosition.axes.x=t}set miny(t){this.minPosition.axes.y=t}set minz(t){this.minPosition.axes.z=t}get maxx(){return this.maxPosition.axes.x}get maxy(){return this.maxPosition.axes.y}get maxz(){return this.maxPosition.axes.z}set maxx(t){this.maxPosition.axes.x=t}set maxy(t){this.maxPosition.axes.y=t}set maxz(t){this.maxPosition.axes.z=t}get angle(){return this.r2d(this._heading)}set angle(t){this._heading=this.d2r(t)}get angler(){return this._heading}set angler(t){this._heading=t}bpm(t=this._bpm){return this._bpm=t,this._bpm}bps(t){return this._bpm=t*60,this._bpm}interval(t){if(this._intervalTime=this.parseAsTime(t),this._intervalTime<MIN_INTERVAL)throw this._intervalTime=MIN_INTERVAL,new Error(`Error setting interval() time, too short: ${targetTime} < ${MIN_INTERVAL}`);return this}async retractspeed(t){if(t!==void 0){const e=this.parseAsTime(t);this._retractSpeed=e*60,await this.sendFirmwareRetractSettings()}return this._retractSpeed}get retractSpeed(){return this._retractSpeed}thick(t){return t!==void 0&&(this.layerHeight=parseFloat(t)),this.layerHeight}async sendFirmwareRetractSettings(){return await this.gcodeEvent("M207 S"+this.retractLength.toFixed(2)+" F"+this._retractSpeed.toFixed(2)+" Z"+this.unretractZHop.toFixed(2)),await this.gcodeEvent("M208 S"+(this.retractLength.toFixed(2)+this.extraUnretract.toFixed(2))+" F"+this._retractSpeed.toFixed(2)),this}async retract(t=this.retractLength,e){if(this.currentRetraction>0)return;if(t<0)throw new Error("[API] retract length can't be less than 0: "+t);let i=!1;t!==this.retractLength&&(i=!0),this.retractLength=t;let r=!1;if(e!==void 0){if(e<=0)throw new Error("[API] retract speed can't be 0 or less: "+e);if(e>this._maxPrintSpeed.e)throw new Error("[API] retract speed to high: "+e);r=!0,this._retractSpeed=e*60}if(this.currentRetraction=this.retractLength,this.e-=this.currentRetraction,this.firmwareRetract)(r||i)&&await this.sendFirmwareRetractSettings(),await this.gcodeEvent("G10");else{const s=this.e.toFixed(4);await this.gcodeEvent("G1 E"+s+" F"+this._retractSpeed.toFixed(4)),this.e=parseFloat(s)}return this.printEvent({type:"retract",speed:this.retractSpeed,length:this.retractLength}),this}async unretract(t=this.currentRetraction,e){if(this.currentRetraction<.01)return;if(t<0)throw new Error("[API] retract length can't be less than 0: "+t);let i=!1;t!==this.retractLength&&(i=!0),this.retractLength=t;let r=!1;if(e!==void 0){if(e<=0)throw new Error("[API] retract speed can't be 0 or less: "+e);if(e>this._maxPrintSpeed.e)throw new Error("[API] retract speed too high: "+e);r=!0,this._retractSpeed=e*60}return this.e+=this.retractLength+this.extraUnretract,this.firmwareRetract?((r||i)&&await this.sendFirmwareRetractSettings(),await this.gcodeEvent("G11")):(this.e=parseFloat(this.e.toFixed(4)),this.currentRetraction=0,await this.gcodeEvent("; unretract"),await this.gcodeEvent("G1 E"+this.e+" F"+this._retractSpeed.toFixed(4))),this.printEvent({type:"unretract",speed:this.retractSpeed,length:this.retractLength}),this}async start(t="190",e="50"){return await this.gcodeEvent("G28"),await this.gcodeEvent("M114"),await this.gcodeEvent("M106 S0"),await this.gcodeEvent("M104 S"+t),await this.sendFirmwareRetractSettings(),this.x=0,this.y=this.maxy,this.z=this.maxz,this.totalMoveTime=0,this.printspeed(this._defaultPrintSpeed),this.travelspeed(this._defaultPrintSpeed),await this.sync(),this}async temp(t="190"){return await this.gcodeEvent("M104 S"+t),this}async tempwait(t="190"){return await this.gcodeEvent("M109 S"+t),this}async bed(t="190"){return await this.gcodeEvent("M140 S"+t),this}async fan(t="100"){return await this.gcodeEvent("M106 S"+t),this}clipToPrinterBounds(t){return t.x=Math.min(t.x,this.maxx),t.y=Math.min(t.y,this.maxy),t.z=Math.min(t.z,this.maxz),t.x=Math.max(t.x,this.minx),t.y=Math.max(t.y,this.miny),t.z=Math.max(t.z,this.minz),t}to({x:t,y:e,z:i,t:r}={}){const s=new liveprinterUtils.Vector(t||this.x,e||this.y,i||this.z),h=i?i-this.z:0,l=liveprinterUtils.Vector.sub(s,this.position);if(this._distance=l.mag(),this._elevation=Math.atan2(h,Math.hypot(l.axes.x,l.axes.y)),this._distance+this._elevation<1e-5){this._elevation=0,this._distance=0;return}return this._heading=Math.atan2(l.axes.y,l.axes.x),liveprinterUtils.Logger.debug(`heading ${this._heading}`),liveprinterUtils.Logger.debug(`heading ${this.angle}`),r&&this.speed(1e3*this._distance/this.parseAsTime(r)),this}_defaultWarp({d:t,heading:e,elevation:i,t:r,tt:s}={}){return{d:t,heading:e,elevation:i}}_defaultTimeWarp({dt:t,t:e,tt:i}={}){return t}_timeWarp({dt:t,t:e,tt:i}){return t}set timewarp(t){this._timeWarp=t}get timewarp(){return this._timeWarp}resettimewarp(){return this.timewarp=this._defaultTimeWarp,this}_warp({d:t,heading:e,elevation:i,t:r,tt:s}={}){return{d:t,heading:e,elevation:i}}set warp(t){this._warp=t}get warp(){return this._warp}resetwarp(){return this.warp=this._defaultWarp,this}async drawtime(t){const e=this.totalMoveTime;let i=0,r=0;const s={speed:this._printSpeed};try{i=this.parseAsTime(t)}catch(l){throw l}this.printEvent({type:"drawtime-start",speed:this._printSpeed,start:e,end:i}),i+=this.totalMoveTime,this._distance=0;let h=2e4;for(;h&&this.totalMoveTime<i;){h--;const l=performance.now(),f=this.x,g=this.y,x=this.z,v=this.totalMoveTime-e,m=this._timeWarp({dt:this._intervalTime,t:v,tt:this.totalMoveTime}),p=this.t2mm(m);let d=0,n=p;const{d:a,heading:w,elevation:y}=this._warp({d:p,heading:this._heading,elevation:this._elevation,t:v,tt:this.totalMoveTime});n=a,r+=a,Math.abs(y)>Number.EPSILON&&(n=a*Math.cos(y),d=a*Math.sin(y)),liveprinterUtils.Logger.debug(`Moved ${a} over (${m} ms) to ${r}}`),s.x=f+n*Math.cos(w),s.y=g+n*Math.sin(w),s.z=x+d,await this.extrudeto(s),liveprinterUtils.Logger.debug(`Move time warp op took ${performance.now()-l} ms vs. expected ${this._intervalTime}.`),this.printEvent({type:"drawtime-start",speed:this._printSpeed,start:e,end:i})}return this}parseAsTime(time,bpm=this._bpm){let targetTime;if(isFinite(time))targetTime=time;else{let timeStr=time+"";if(timeStr=timeStr.toLowerCase(),/^[a-z]/.test(timeStr))return targetTime=this.m2s(timeStr),targetTime;const params=timeStr.match(TimeRegex);if(params&&params.length==3){const numberParam=eval(params[1]);switch(params[2]){case"s":targetTime=numberParam/1e3;break;case"ms":targetTime=numberParam;break;case"b":targetTime=6e4/bpm*numberParam;break;default:throw new Error(`parseAsTime::Error parsing time, bad time suffix in ${timeStr}`)}}else throw new Error(`parseAsTime::Error parsing time, check the format of ${timeStr}`)}return targetTime}async draw(t){const e=this.totalMoveTime;let i=0;this._distance=t&&isFinite(t)?t:this._distance;const r=this._distance,s={speed:this._printSpeed};let h=2e4;for(this.printEvent({type:"draw-start",speed:this._printSpeed,length:this._distance});h&&i<r;){h--;const l=this.totalMoveTime-e,f=performance.now(),g=this.x,x=this.y,v=this.z,m=this._timeWarp({dt:this._intervalTime,t:l,tt:this.totalMoveTime}),p=Math.min(this.t2mm(m),r-i),{d,heading:n,elevation:a}=this._warp({d:p,heading:this._heading,elevation:this._elevation,t:l,tt:this.totalMoveTime});if(p+a<1e-5){console.error(`draw() SHORT: ${h}, ${r} ${r-i} / ${p}`);break}let w=d*Math.sin(a),y=d*Math.cos(a);s.x=g+y*Math.cos(n),s.y=x+y*Math.sin(n),s.z=v+w,await this.extrudeto(s),i+=p,liveprinterUtils.Logger.debug(`Moved ${p} to ${i} towards ${r}`),liveprinterUtils.Logger.debug(`Move draw warp op took ${performance.now()-f} ms vs. expected ${this._intervalTime}.`)}return this._elevation=0,this._distance=0,this.printEvent({type:"draw-end",speed:this._printSpeed,length:i}),this}set layerHeight(t){this._layerHeight=Math.max(MinLayerHeight,t)}set lh(t){this._layerHeight=Math.max(MinLayerHeight,t)}get layerHeight(){return this._layerHeight}get lh(){return this._layerHeight}getAngle(t=!1){return t?this._heading:this.r2d(this._heading)}turnto(t,e=!1){return this._heading=e?t:this.d2r(t),this}run(t){const e="M",i="E",r="L",s="R",h="U",l="D",f="<",g=">",x=/([a-zA-Z<>][0-9]+\.?[0-9]*)/gim,v=/([a-zA-Z<>])([0-9]+\.?[0-9]*)/,m=t.match(x);for(let p of m){let d=p.match(v);if(d.length!==3)throw new Error("[API] Error in command string: "+m);const n=d[1].toUpperCase(),a=parseFloat(d[2]);switch(n){case e:this.distance(a).go();break;case i:this.distance(a).go(1,!1);break;case r:this.turn(a);break;case s:this.turn(-a);break;case h:this.up(a).go();break;case l:this.down(a).go();break;case f:this.retract(a);break;case g:this.unretract(a);break;default:throw new Error("[API] Error in command - unknown command char: "+n)}}return this}async up(t){return this.move({z:t,speed:this._travelSpeed})}async drawup(t){const e=t;return this._elevation=Math.PI/2,this.draw({z:e})}async dup(t){return this.drawup(t)}async upto(t){return this.moveto({z:t,speed:this._travelSpeed})}async downto(t){return this.upto(t)}async down(t){return this.up(-t)}async drawdown(t){return this.drawup(-t)}async dd(t){return this.drawdown(t)}elevation(t,e=!1){return e||(t=this.d2r(t)),this._elevation=t,this}elev(t){return this.elevation(t)}tilt(t){return this.elevation(t)}distance(t){return this._distance=t,this}dist(t){return this.distance(t)}async travel(t){const e=this.totalMoveTime;let i=0;const r=t&&isFinite(t)?t:this._distance,s={speed:this._travelSpeed};this._distance=0;let h=800;for(;h&&i<r;){h--;const l=performance.now(),f=this.totalMoveTime-e,g=this.x,x=this.y,v=this.z,m=this._timeWarp({dt:this._intervalTime,t:f,tt:this.totalMoveTime}),p=Math.min(this.t2mm(m),r-i);let d=0,n=p,{d:a,heading:w,elevation:y}=this._warp({d:p,heading:this._heading,elevation:this._elevation,t:f,tt:this.totalMoveTime});if(p+y<1e-5)break;n=a,Math.abs(y)>Number.EPSILON&&(n=a*Math.cos(y),d=a*Math.sin(y)),s.x=g+n*Math.cos(w),s.y=x+n*Math.sin(w),s.z=v+d,await this.moveto(s),i+=p,liveprinterUtils.Logger.debug(`Moved ${p} to ${i} towards ${r}`),liveprinterUtils.Logger.debug(`Move time warp op (${m}) took ${performance.now()-l} ms vs. expected ${this._intervalTime}.`)}return this._elevation=0,this}async traveltime(t){const e=this.totalMoveTime;let i=0,r=0;const s={speed:this._travelSpeed};try{i=this.parseAsTime(t)}catch(l){throw l}i+=this.totalMoveTime,this._distance=0;let h=2e4;for(;h&&this.totalMoveTime<i;){h--;const l=performance.now(),f=this.x,g=this.y,x=this.z,v=this.totalMoveTime-e,m=this._timeWarp({dt:this._intervalTime,t:v,tt:this.totalMoveTime}),p=this.t2mm(m);let d=0,n=p,{d:a,heading:w,elevation:y}=this._warp({d:p,heading:this._heading,elevation:this._elevation,t:v,tt:this.totalMoveTime});n=a,r+=a,Math.abs(y)>Number.EPSILON&&(n=a*Math.cos(y),d=a*Math.sin(y)),liveprinterUtils.Logger.debug(`Moved ${a} over (${m} ms) to ${r}}`),s.x=f+n*Math.cos(w),s.y=g+n*Math.sin(w),s.z=x+d,await this.moveto(s),liveprinterUtils.Logger.debug(`Move time warp op took ${performance.now()-l} ms vs. expected ${this._intervalTime}.`)}return this}async fwretract(t){return this.firmwareRetract=t,this.fwretract?await this.gcodeEvent("M209 S0"):await this.gcodeEvent("M209 S1"),this}async polygon(t,e=10){const i=t*t*2,r=Math.PI*2/e,s=Math.sqrt(i-i*Math.cos(r)),h=this._autoRetract;this._autoRetract=!1;for(let l=0;l<e;l++)this.turn(r,!0),await this.draw(s);return this._autoRetract=h,this._autoRetract&&await this.retract(),this}async rect({w:t,h:e}){const i=this._autoRetract;this._autoRetract=!1;const r=t||e,s=e||t;for(let h=0;h<2;h++)await this.draw(r),this.turn(90),await this.draw(s),this.turn(90);return this._autoRetract=i,await this.retract(),await this.travel(r),this}async extrudeto(t){const e=t.e===void 0,i=t.x!==void 0?parseFloat(t.x):this.x,r=t.y!==void 0?parseFloat(t.y):this.y,s=t.z!==void 0?parseFloat(t.z):this.z,h=t.e!==void 0?parseFloat(t.e):this.e,l=Math.abs(h-this.e)>1e-4,f=e||l,g=e&&l&&(t.retract===!0||t.retract===void 0&&this._autoRetract);!e&&l&&(this.currentRetraction=0),g&&await this.unretract();let x=new liveprinterUtils.Vector({x:i,y:r,z:s,e:h}),v=parseFloat(t.speed!==void 0?t.speed:f?this._printSpeed:this._travelSpeed);this.layerHeight=parseFloat(t.thickness!==void 0?t.thickness:this.layerHeight),t.thick!==void 0&&(this.layerHeight=parseFloat(t.thick));const m=liveprinterUtils.Vector.sub(x,this.position),p=new liveprinterUtils.Vector(m.axes.x,m.axes.y,m.axes.z);let d,n;if(d=p.mag(),!l&&d<Number.EPSILON)return;if(d<1e-4?n=1e3*m.axes.e/v:n=1e3*d/v,Number.isNaN(n))throw new Error("Movetime NAN in extrudeTo");if(e){liveprinterUtils.Logger.debug(`moveTime: ${n}`);const y=this._filamentDiameter/2;let P=d*this.layerHeight*this.layerHeight;if(P>this.maxFilamentPerOperation)throw Error("[API] Too much filament in move:"+P);this._extrusionInmm3||(P/=y*y*Math.PI),m.axes.e=P,x.axes.e=this.e+m.axes.e}if(x=this.clipToPrinterBounds(x.axes),this.totalMoveTime+=n,liveprinterUtils.Logger.debug("time: "+n+" / dist:"+d),n>this.maxTimePerOperation)throw new Error("[API] move time too long:"+n);if(n<.001)throw this.errorEvent("[API] total move time too short:"+n),new Error("[API] move time too short:"+n);const a=liveprinterUtils.Vector.div(m,n/1e3);if(liveprinterUtils.Logger.debug(a),f){if(Math.abs(a.axes.x)>this._maxPrintSpeed.x)throw Error("[API] X printing speed too fast:"+a.axes.x);if(Math.abs(a.axes.y)>this._maxPrintSpeed.y)throw Error("[API] Y printing speed too fast:"+a.axes.y);if(Math.abs(a.axes.z)>this._maxPrintSpeed.z)throw Error("[API] Z printing speed too fast:"+a.axes.z);if(Math.abs(a.axes.e)>this._maxPrintSpeed.e)throw Error("[API] E printing speed too fast:"+a.axes.e+"/"+this._maxPrintSpeed.e)}else{if(Math.abs(a.axes.x)>this._maxTravelSpeed.x)throw Error("[API] X travel too fast:"+a.axes.x);if(Math.abs(a.axes.y)>this._maxTravelSpeed.y)throw Error("[API] Y travel too fast:"+a.axes.y);if(Math.abs(a.axes.z)>this._maxTravelSpeed.z)throw Error("[API] Z travel too fast:"+a.axes.z)}const w={...this.position.axes};this.position.set(x),await this.sendExtrusionGCode(v),f?this.printEvent({type:"extrude",newPosition:{...this.position.axes},oldPosition:{...w},speed:this._printSpeed,moveTime:n,totalMoveTime:this.totalMoveTime,layerHeight:this.layerHeight,length:d}):this.printEvent({type:"travel",newPosition:{...this.position.axes},oldPosition:{...w},speed:this._travelSpeed,moveTime:n,totalMoveTime:this.totalMoveTime,layerHeight:this.layerHeight,length:d}),g&&await this.retract()}async sendExtrusionGCode(t){this.e=parseFloat(this.e.toFixed(4)),this.x=parseFloat(this.x.toFixed(4)),this.y=parseFloat(this.y.toFixed(4)),this.z=parseFloat(this.z.toFixed(4));let e=["G1"];return e.push("X"+this.x),e.push("Y"+this.y),e.push("Z"+this.z),e.push("E"+this.e),e.push("F"+(t*60).toFixed(4)),await this.gcodeEvent(e.join(" ")),this}async sendArcExtrusionGCode(t,e=!0,i=!0){let r=clockwise?["G2"]:["G3"];return r.push("X"+this.x.toFixed(4)),r.push("Y"+this.y.toFixed(4)),r.push("Z"+this.z.toFixed(4)),r.push("E"+this.e.toFixed(4)),r.push("F"+(t*60).toFixed(4)),await this.gcodeEvent(r.join(" ")),this.e=parseFloat(this.e.toFixed(4)),this.x=parseFloat(this.x.toFixed(4)),this.y=parseFloat(this.y.toFixed(4)),this.z=parseFloat(this.z.toFixed(4)),this}async extrude(t){let e={};return e.x=t.x!==void 0?parseFloat(t.x)+this.x:this.x,e.y=t.y!==void 0?parseFloat(t.y)+this.y:this.y,e.z=t.z!==void 0?parseFloat(t.z)+this.z:this.z,e.e=t.e!==void 0?parseFloat(t.e)+this.e:void 0,e.retract=t.retract,e.speed=t.speed,this.extrudeto(e)}async move(t){let e={};return e.x=t.x!==void 0?parseFloat(t.x)+this.x:this.x,e.y=t.y!==void 0?parseFloat(t.y)+this.y:this.y,e.z=t.z!==void 0?parseFloat(t.z)+this.z:this.z,e.e=this.e,t.speed!==void 0&&this.travelspeed(parseFloat(t.speed)),e.speed=this._travelSpeed,this.extrudeto(e)}async moveto(t){return t.e=this.e,t.speed=t.speed===void 0?this._travelSpeed:parseFloat(t.speed),this._travelSpeed=t.speed,this.extrudeto(t)}turn(t,e=!1){let i=t;return e||(i=this.d2r(t)),this._heading+=i,this}async drawfill(t,e,i){i===void 0&&(i=1.5*this.layerHeight);const r=this._autoRetract;this._autoRetract=!1,o;let s=t/i;if(s<3)await this.draw(e);else{s%2!==0&&(s+=1);for(let h=0;h<s;h++){let l=h%2===0?-1:1;await this.draw(e),this.turn(l*90),await this.draw(i),this.turn(l*90)}this.turn(180)}return this._autoRetract=r,this._autoRetract&&await this.retract(),this}async sync(){return await this.gcodeEvent("M105"),await this.gcodeEvent("M114"),this}d2r(t){return Math.PI*t/180}r2d(t){return t*180/Math.PI}note(t=40,e=200,i="x"){const r=[];r.push(...i);let s=0,h=0,l=0,f=0;for(const g of r)if(t<10){this._waitTime=e;break}else{let x=this.midi2speed(t,g);s+=x*x,g==="x"?this._heading<Math.PI/2&&this._heading>-Math.PI/2?l=-90:l=90:g==="y"?this._heading>0&&this._heading<Math.PI?h=90:h=-90:g==="z"&&(this._elevation>0?f=Math.PI/2:f=-Math.PI/2)}return this._heading=Math.atan2(h,l),this._elevation=f,this._distance=this.printpeed(Math.sqrt(s))*e/1e3,this}t2d(t,e=this._travelSpeed){const i=this.parseAsTime(t),r=this.parseAsTime(e);return this._distance=this.t2mm(i,r),this}t2mm(t,e=this._printSpeed){const i=this.parseAsTime(t);return this.parseAsTime(e)*i/1e3}n2mm(t,e="1b",i=this._bpm){const r=this.midi2speed(t),s=this.parseAsTime(e,i);return r*s/1e3}b2t(t,e=this._bpm){return this.parseAsTime(t,e)}d2t(t=this._distance,e=this._printSpeed){return Math.abs(t)*e}async fill(t,e,i=this.layerHeight){let r=i*Math.PI;for(var s=0,h=0;h<e;s++,h+=r){let l=s%2===0?1:-1;await this.move({y:r}),await this.extrude({x:l*t})}return this}midi2speed(t,e="x"){let i=isNaN(t)?tonal.Note.midi(t):t;return Math.pow(2,(i-69)/12)*440/parseFloat(this.speedScale()[e])}m2s(t,e="x"){return this.travelspeed(this.printspeed(this.midi2speed(t,e)))}speedScale(){let t=this._speedScale;return{x:t.x,y:t.y,z:t.z}}async wait(t=this._waitTime){return await this.gcodeEvent("G4 P"+t),this._waitTime=0,this}async pause(){return await this.extrude({e:-16,speed:250}),await this.move({z:-3}),await this.gcodeEvent("M104 S0"),await this.gcodeEvent("M107 S0"),this}async resume(t="190"){return await this.gcodeEvent("M109 S"+t),await this.gcodeEvent("M106 S100"),await this.extrude({e:16,speed:250}),this}async printPaths({paths:t=[[]],y:e=0,x:i=0,z:r=0,w:s=0,h=0,useaspect:l=!0,passes:f=1,safeZ:g=0}){g=g||this.layerHeight*f+10;let x=1/0,v=1/0,m=-1/0,p=-1/0,d=t.length;for(;d--;){let u=t[d].length,c={x:1/0,y:1/0,x2:-1/0,y2:-1/0,area:0};for(;u--;)x=Math.min(t[d][u][0],x),v=Math.min(t[d][u][1],v),m=Math.max(t[d][u][0],m),p=Math.max(t[d][u][1],p),t[d][u][0]<c.x&&(c.x=t[d][u][0]),t[d][u][1]<c.y&&(c.y=t[d][u][0]),t[d][u][0]>c.x2&&(c.x2=t[d][u][0]),t[d][u][1]>c.y2&&(c.y2=t[d][u][0]);c.area=(1+c.x2-c.x)*(1+c.y2-c.y),t[d].bounds=c}const n=m-x,a=p-v,w=s&&h,y=s||h;if(!w)if(y)if(s>0){const u=a/n;h=s*u}else{const u=n/a;s=h*u}else s=n,h=a;const P=makeMapping([x,m],[i,i+s]),T=makeMapping([v,p],[e,e+h]);t.sort(function(u,c){return u.bounds.x<c.bounds.x?-1:1});for(let u=0,c=t.length;u<c;u++){let _=t[u].slice();for(let S=1;S<=f;S++){const M=S*this.layerHeight+r;await this.moveto({x:P(_[0][0]),y:T(_[0][1])}),await this.moveto({z:M}),await this.unretract();for(let b=0,z=_.length;b<z;b++){const E=_[b];await this.extrudeto({x:P(E[0]),y:T(E[1]),retract:!1})}S<f?_.reverse():(await this.retract(),await this.moveto({z:g}))}}return this}async printPathsThick({paths:t=[[]],y:e=0,x:i=0,z:r=0,w:s=0,h=0,t:l=1,useaspect:f=!0,passes:g=1,safeZ:x=0}){x=x||this.layerHeight*g+10,l=this.layerHeight*2.5*l;let v=1/0,m=1/0,p=-1/0,d=-1/0,n=t.length;for(;n--;){let c=t[n].length,_={x:1/0,y:1/0,x2:-1/0,y2:-1/0,area:0};for(;c--;)v=Math.min(t[n][c][0],v),m=Math.min(t[n][c][1],m),p=Math.max(t[n][c][0],p),d=Math.max(t[n][c][1],d),t[n][c][0]<_.x&&(_.x=t[n][c][0]),t[n][c][1]<_.y&&(_.y=t[n][c][0]),t[n][c][0]>_.x2&&(_.x2=t[n][c][0]),t[n][c][1]>_.y2&&(_.y2=t[n][c][0]);t[n].bounds=_}const a=p-v,w=d-m,y=s&&h,P=s||h;if(!y)if(P)if(s>0){const c=w/a;h=s*c}else{const c=a/w;s=h*c}else s=a,h=w;const T=makeMapping([v,p],[i,i+s]),u=makeMapping([m,d],[e,e+h]);t.sort(function(c,_){return c.bounds.x<_.bounds.x?-1:1});for(let c=1;c<=g;c++)for(let _=0,S=t.length;_<S;_++){let M=t[_].slice();const b=c*this.layerHeight+r;if(await this.moveto({x:T(M[0][0]),y:u(M[0][1])}),await this.moveto({z:b}),M.length>1){let z=0,E=0,I=T(M[0][0]),A=u(M[0][1]),R=Math.atan2(u(M[1][1])-A,T(M[1][0])-I);for(let L=1,k=M.length;L<k;L++){const U=M[L],N=T(U[0]),C=u(U[1]),H=N-I,$=C-A,F=Math.atan2($,H);F!==R?(await this.drawfill(z||2,E||2,l),z=E=0,this.turn(F),R=F):(z+=H,E+=$)}}c<g?M.reverse():await this.moveto({z:x})}return this}}exports.LivePrinter=LivePrinter,Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"})});
